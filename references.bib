
@book{beckTestDrivenDevelopment2022,
	title = {Test {Driven} {Development}: {By} {Example}},
	isbn = {978-0-13-758523-6},
	shorttitle = {Test {Driven} {Development}},
	abstract = {Quite simply, test-driven development is meant to eliminate fear in application development. While some fear is healthy (often viewed as a conscience that tells programmers to "be careful!"), the author believes that byproducts of fear include tentative, grumpy, and uncommunicative programmers who are unable to absorb constructive criticism. When programming teams buy into TDD, they immediately see positive results. They eliminate the fear involved in their jobs, and are better equipped to tackle the difficult challenges that face them. TDD eliminates tentative traits, it teaches programmers to communicate, and it encourages team members to seek out criticism However, even the author admits that grumpiness must be worked out individually! In short, the premise behind TDD is that code should be continually tested and refactored. Kent Beck teaches programmers by example, so they can painlessly and dramatically increase the quality of their work.},
	language = {en},
	publisher = {Addison-Wesley Professional},
	author = {Beck, Kent},
	month = mar,
	year = {2022},
	note = {Google-Books-ID: zNnPEAAAQBAJ},
	keywords = {Computers / Software Development \& Engineering / General, Computers / Software Development \& Engineering / Quality Assurance \& Testing},
}

@article{dongarra2015hpcg,
	title = {Hpcg benchmark: a new metric for ranking high performance computing systems},
	volume = {42},
	journal = {Knoxville, Tennessee},
	author = {Dongarra, Jack and Heroux, Michael A and Luszczek, Piotr},
	year = {2015},
}

@misc{MantevoHPCCG2023,
	title = {Mantevo/{HPCCG}},
	copyright = {BSD-3-Clause},
	url = {https://github.com/Mantevo/HPCCG},
	abstract = {High Performance Computing Conjugate Gradients:  The original Mantevo miniapp},
	urldate = {2024-03-05},
	publisher = {The Mantevo Performance Co-design Project},
	month = oct,
	year = {2023},
	note = {original-date: 2017-07-02T13:46:43Z},
}

@inproceedings{treibigLIKWIDLightweightPerformance2012,
	address = {Berlin, Heidelberg},
	title = {{LIKWID}: {Lightweight} {Performance} {Tools}},
	isbn = {978-3-642-24025-6},
	shorttitle = {{LIKWID}},
	doi = {10.1007/978-3-642-24025-6_14},
	abstract = {Exploiting the performance of today’s microprocessors requires intimate knowledge of the microarchitecture as well as an awareness of the ever-growing complexity in thread and cache topology. LIKWID is a set of command line utilities that addresses four key problems: Probing the thread and cache topology of a shared-memory node, enforcing thread-core affinity on a program, measuring performance counter metrics, and microbenchmarking for reliable upper performance bounds. Moreover, it includes an mpirun wrapper allowing for portable thread-core affinity in MPI and hybrid MPI/threaded applications. To demonstrate the capabilities of the tool set we show the influence of thread affinity on performance using the well-known OpenMP STREAM triad benchmark, use hardware counter tools to study the performance of a stencil code, and finally show how to detect bandwidth problems on ccNUMA-based compute nodes.},
	language = {en},
	booktitle = {Competence in {High} {Performance} {Computing} 2010},
	publisher = {Springer},
	author = {Treibig, Jan and Hager, Georg and Wellein, Gerhard},
	editor = {Bischof, Christian and Hegering, Heinz-Gerd and Nagel, Wolfgang E. and Wittum, Gabriel},
	year = {2012},
	keywords = {Command Line Tool, Memory Bandwidth, NUMA Domain, Performance Counter, Thread Count},
	pages = {165--175},
}

@misc{EmpiricalRooflineTool,
	title = {Empirical {Roofline} {Tool} ({ERT})},
	url = {https://crd.lbl.gov/divisions/amcr/computer-science-amcr/par/research/roofline/software/ert/},
	abstract = {The Empirical Roofline Tool (ERT) empirically determines the machine characteristics (CPU or GPU-accelerated) that are needed to generate the machine5},
	language = {en},
	urldate = {2024-03-04},
	journal = {Computing Sciences Research},
}

@misc{RRZEHPCLikwid2024,
	title = {{RRZE}-{HPC}/likwid},
	copyright = {GPL-3.0},
	url = {https://github.com/RRZE-HPC/likwid},
	abstract = {Performance monitoring and benchmarking suite},
	urldate = {2024-03-04},
	publisher = {RRZE-HPC},
	month = mar,
	year = {2024},
	note = {original-date: 2015-05-04T16:13:45Z},
	keywords = {armv8, assembly, benchmarking, c, hardware-performance-counters, hwloc, instrumentation, likwid, linux, lua, nvidia-gpu, performance-analysis, performance-engineering, pin, power9, profiling, threading, x86},
}

@inproceedings{yangEmpiricalRooflineMethodology2018,
	title = {An {Empirical} {Roofline} {Methodology} for {Quantitatively} {Assessing} {Performance} {Portability}},
	url = {https://ieeexplore.ieee.org/abstract/document/8639946},
	doi = {10.1109/P3HPC.2018.00005},
	abstract = {System and node architectures continue to diversify to better balance on-node computation, memory capacity, memory bandwidth, interconnect bandwidth, power, and cost for specific computational workloads. For many application developers, achieving performance portability (effectively exploiting the capabilities of multiple architectures) is a desired goal. Unfortunately, dramatically different per-node performance coupled with differences in machine balance can lead to developers being unable to determine whether they have attained performance portability or simply written portable code. The Roofline model provides a means of quantitatively assessing how well a given application makes use of a target platform's computational capabilities. In this paper, we extend the Roofline model so that it 1) empirically captures a more realistic set of performance bounds for CPUs and GPUs, 2) factors in the true cost of different floating-point instructions when counting FLOPs, 3) incorporates the effects of different memory access patterns, and 4) with appropriate pairing of code performance and Roofline ceiling, facilitates the performance portability analysis.},
	urldate = {2024-03-04},
	booktitle = {2018 {IEEE}/{ACM} {International} {Workshop} on {Performance}, {Portability} and {Productivity} in {HPC} ({P3HPC})},
	author = {Yang, Charlene and Gayatri, Rahulkumar and Kurth, Thorsten and Basu, Protonu and Ronaghi, Zahra and Adetokunbo, Adedoyin and Friesen, Brian and Cook, Brandon and Doerfler, Douglas and Oliker, Leonid and Deslippe, Jack and Williams, Samuel},
	month = nov,
	year = {2018},
	keywords = {Bandwidth, Computational modeling, Computer architecture, GPU, Graphics processing units, Instruction sets, KNL, Kernel, Measurement, Roofline, performance-counters, performance-model, performance-portability},
	pages = {14--23},
}

@misc{PressReleaseFuture2024,
	title = {Press {Release}: {Future} {Software} {Should} {Be} {Memory} {Safe} {\textbar} {ONCD}},
	shorttitle = {Press {Release}},
	url = {https://www.whitehouse.gov/oncd/briefing-room/2024/02/26/press-release-technical-report/},
	abstract = {Leaders in Industry Support White House Call to Address Root Cause of Many of the Worst Cyber Attacks Read the full report here WASHINGTON – Today, the White House Office of the National Cyber Director (ONCD) released a report calling on the technical community to proactively reduce the attack surface in cyberspace. ONCD makes the…},
	language = {en-US},
	urldate = {2024-03-04},
	journal = {The White House},
	month = feb,
	year = {2024},
}

@misc{262588213843476MakingRustPerfect,
	title = {Making {Rust} a perfect fit for high-performance computations},
	url = {https://gist.github.com/HadrienG2/e9a875bdf98b528594f4e20f8176bb68},
	abstract = {Making Rust a perfect fit for high-performance computations - High\_Performance\_Rust.md},
	language = {en},
	urldate = {2024-01-02},
	journal = {Gist},
	author = {262588213843476},
}

@article{franzenEvaluationRustGPGPU2022,
	title = {Evaluation of {Rust} for {GPGPU} high-performance computing},
	url = {https://hdl.handle.net/20.500.12380/305693},
	abstract = {Research within computer science constantly aims to find ways to improve computing performance in various ways. With the apparent death of Moore’s Law, researchers are focused on exploiting other ways of improving performance, for example, programming language optimizations. Fields such as web development, databases and, machine learning are adopting new programming languages but GPU programming is not seeing this adoption. This thesis aims to evaluate Rust as a competitor to the status quo of programming languages for GPU programming, namely C++. In order to achieve this, comparable CUDA kernels are built in both C++ and Rust which are then profiled and analyzed for insights that can indicate reasons why one might outperform the other. The results show that execution time and energy consumption of C++ kernels are lower in nearly every experiment when having line-by-line comparable code. However, slight adjustments to the implementation of the Rust kernels close this gap to the point that they are performing at the same level. This indicates that it is possible to implement high-performance GPGPU programs in Rust, while still bringing some of its features such as memory safety and modern programming utilities to the GPU programming community.},
	language = {eng},
	urldate = {2024-01-02},
	author = {Franzén, Viktor and Östling, Carl},
	year = {2022},
}

@inproceedings{bychkovRustLanguageSupercomputing2021,
	address = {Cham},
	series = {Communications in {Computer} and {Information} {Science}},
	title = {Rust {Language} for {Supercomputing} {Applications}},
	isbn = {978-3-030-92864-3},
	doi = {10.1007/978-3-030-92864-3_30},
	abstract = {Rust is a promising compiled programming language that has gained in popularity in recent years, as well as support from corporations. It allows one to create efficient code, but it also provides a higher level of security and predictability. In this paper, we study how Rust is currently ready for building supercomputing applications. Performance testing when creating new code, using math libraries, and using multithreading shows that the language is capable of delivering C++-level performance without any special effort. MPI benchmarking on the cluster shows that the technology does work without the overhead.},
	language = {en},
	booktitle = {Supercomputing},
	publisher = {Springer International Publishing},
	author = {Bychkov, Andrey and Nikolskiy, Vsevolod},
	editor = {Voevodin, Vladimir and Sobolev, Sergey},
	year = {2021},
	keywords = {BLAS, MPI, Rayon, Rust language, Shared-memory parallelism},
	pages = {391--403},
}

@misc{diehlBenchmarkingParallel1D2023,
	title = {Benchmarking the {Parallel} {1D} {Heat} {Equation} {Solver} in {Chapel}, {Charm}++, {C}++, {HPX}, {Go}, {Julia}, {Python}, {Rust}, {Swift}, and {Java}},
	url = {http://arxiv.org/abs/2307.01117},
	doi = {10.48550/arXiv.2307.01117},
	abstract = {Many scientific high performance codes that simulate e.g. black holes, coastal waves, climate and weather, etc. rely on block-structured meshes and use finite differencing methods to iteratively solve the appropriate systems of differential equations. In this paper we investigate implementations of an extremely simple simulation of this type using various programming systems and languages. We focus on a shared memory, parallelized algorithm that simulates a 1D heat diffusion using asynchronous queues for the ghost zone exchange. We discuss the advantages of the various platforms and explore the performance of this model code on different computing architectures: Intel, AMD, and ARM64FX. As a result, Python was the slowest of the set we compared. Java, Go, Swift, and Julia were the intermediate performers. The higher performing platforms were C++, Rust, Chapel, Charm++, and HPX.},
	urldate = {2024-01-02},
	publisher = {arXiv},
	author = {Diehl, Patrick and Brandt, Steven R. and Morris, Max and Gupta, Nikunj and Kaiser, Hartmut},
	month = jul,
	year = {2023},
	note = {arXiv:2307.01117 [cs]},
	keywords = {Computer Science - Distributed, Parallel, and Cluster Computing},
}

@phdthesis{sudwojRustProgrammingLanguage2020,
	type = {Bachelor {Thesis}},
	title = {Rust programming language in the high-performance computing environment},
	copyright = {http://rightsstatements.org/page/InC-NC/1.0/},
	url = {https://www.research-collection.ethz.ch/handle/20.500.11850/474922},
	abstract = {Fortran and C++ have traditionally been the languages of choice for high-performance computing (HPC) applications. However, they are both over 35 years old, and do not offer much in terms of user-friendliness or memory safety. Rust is an emergent new systems language, aiming to be performant while offering such safety and usability, as well as bundling tools that a modern developer needs.  We compare multiple implementations of a finite difference stencil code, and show that idiomatically written Rust programs can be just as performant as their Fortran or C++ counterparts, while offering the above-mentioned advantages.},
	language = {en},
	urldate = {2024-01-02},
	school = {ETH Zurich},
	author = {Sudwoj, Michal},
	month = sep,
	year = {2020},
	doi = {10.3929/ethz-b-000474922},
	note = {Accepted: 2021-03-17T09:09:08Z},
}

@inproceedings{costanzoPerformanceVsProgramming2021,
	title = {Performance vs {Programming} {Effort} between {Rust} and {C} on {Multicore} {Architectures}: {Case} {Study} in {N}-{Body}},
	shorttitle = {Performance vs {Programming} {Effort} between {Rust} and {C} on {Multicore} {Architectures}},
	url = {https://ieeexplore.ieee.org/abstract/document/9640225},
	doi = {10.1109/CLEI53233.2021.9640225},
	abstract = {Historically, Fortran and C have been the default programming languages in High-Performance Computing (HPC). In both, programmers have primitives and functions available that allow manipulating system memory and interacting directly with the underlying hardware, resulting in efficient code in both response times and resource use. On the other hand, it is a real challenge to generate code that is maintainable and scalable over time in these types of languages. In 2010, Rust emerged as a new programming language designed for concurrent and secure applications, which adopts features of procedural, object-oriented and functional languages. Among its design principles, Rust is aimed at matching C in terms of efficiency, but with increased code security and productivity. This paper presents a comparative study between C and Rust in terms of performance and programming effort, selecting as a case study the simulation of N computational bodies (N-Body), a popular problem in the HPC community. Based on the experimental work, it was possible to establish that Rust is a language that reduces programming effort while maintaining acceptable performance levels, meaning that it is a possible alternative to C for HPC.},
	urldate = {2024-01-02},
	booktitle = {2021 {XLVII} {Latin} {American} {Computing} {Conference} ({CLEI})},
	author = {Costanzo, Manuel and Rucci, Enzo and Naiouf, Marcelo and Giusti, Armando De},
	month = oct,
	year = {2021},
	pages = {1--10},
}

@techreport{gasparRustHPC2018,
	title = {Rust in {HPC}},
	url = {https://www.osti.gov/biblio/1485376},
	abstract = {No abstract provided.},
	language = {English},
	number = {LA-UR-18-31540},
	urldate = {2024-01-02},
	institution = {Los Alamos National Lab. (LANL), Los Alamos, NM (United States)},
	author = {Gaspar, Andrew James},
	month = dec,
	year = {2018},
	doi = {10.2172/1485376},
}

@article{sautterOBSERVINGPARALLELEXECUTION,
	title = {{OBSERVING} {THE} {PARALLEL} {EXECUTION} {OF} {RUST} {PROGRAMS}},
	url = {https://www.en.pms.ifi.lmu.de/publications/diplomarbeiten/Frederic.Sautter/MA_Frederic.Sautter.pdf},
	urldate = {2024-01-02},
	author = {Sautter, Frederic Pascal},
}

@inproceedings{kailasaMostlyPainlessScientific,
	title = {Mostly {Painless} {Scientific} {Computing} {With} {Rust}},
	url = {https://www.semanticscholar.org/paper/Mostly-Painless-Scientific-Computing-With-Rust-Kailasa-Betcke/13520195590851b7eb19361a9596dd0aaa46a536},
	abstract = {Scientific software is required to be fast, painless to change, and easy to deploy. Historically, compiled languages such as C/C++ and Fortran have been preferred when writing software with the highest performance requirements. However these languages are complex, and the resulting software is challenging to maintain and deploy across platforms. We present our recent software projects written in Rust, a fast-growing, ergonomic, systems-level programming language with a toolchain designed for high-performance and simple cross platform builds. We illustrate the current state of the scientific computing ecosystem in Rust, through our experience developing high-performance MPI-distributed software for computational physics problems. CCSConcepts},
	urldate = {2024-01-02},
	author = {Kailasa, Srinath and Betcke, Timo},
}

@techreport{moranEmergingTechnologiesRust2023,
	title = {Emerging {Technologies}: {Rust} in {HPC}},
	shorttitle = {Emerging {Technologies}},
	url = {https://zenodo.org/records/7620406},
	abstract = {This technical report is a short investigation into how Rust could be used for a scientific application in a HPC system. A computational fluid dynamics model of fluid flow into and out of a box was developed in Rust and compared to the same algorithm implemented in C and Fortran. These simulations were performed for both serial and parallelised versions over a variety of problem sizes. The report discusses the results of these simulations and the implications for using Rust as a tool for scientific programming in HPC.},
	urldate = {2024-01-02},
	institution = {Zenodo},
	author = {Moran, Laura and Bull, J. Mark},
	month = feb,
	year = {2023},
	doi = {10.5281/zenodo.7620406},
}

@inproceedings{parrishSafeHPCProductivity2023,
	address = {New York, NY, USA},
	series = {{MPLR} 2023},
	title = {Towards {Safe} {HPC}: {Productivity} and {Performance} via {Rust} {Interfaces} for a {Distributed} {C}++ {Actors} {Library} ({Work} in {Progress})},
	isbn = {9798400703805},
	shorttitle = {Towards {Safe} {HPC}},
	url = {https://dl.acm.org/doi/10.1145/3617651.3622992},
	doi = {10.1145/3617651.3622992},
	abstract = {In this work-in-progress research paper, we make the case for using Rust to develop applications in the High Performance Computing (HPC) domain which is critically dependent on native C/C++ libraries. This work explores one example of Safe HPC via the design of a Rust interface to an existing distributed C++ Actors library. This existing library has been shown to deliver high performance to C++ developers of irregular Partitioned Global Address Space (PGAS) applications. Our key contribution is a proof-of-concept framework to express parallel programs safe-ly in Rust (and potentially other languages/systems), along with a corresponding study of the problems solved by our runtime, the implementation challenges faced, and user productivity. We also conducted an early evaluation of our approach by converting C++ actor implementations of four applications taken from the Bale kernels to Rust Actors using our framework. Our results show that the productivity benefits of our approach are significant since our Rust-based approach helped catch bugs statically during application development, without degrading performance relative to the original C++ actor versions.},
	urldate = {2024-01-02},
	booktitle = {Proceedings of the 20th {ACM} {SIGPLAN} {International} {Conference} on {Managed} {Programming} {Languages} and {Runtimes}},
	publisher = {Association for Computing Machinery},
	author = {Parrish, John and Wren, Nicole and Kiang, Tsz Hang and Hayashi, Akihiro and Young, Jeffrey and Sarkar, Vivek},
	month = oct,
	year = {2023},
	keywords = {Rust, actors, high performance computing, unsafe annotations},
	pages = {165--172},
}

@inproceedings{bleselHeimdallrImprovingCompile2021,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {heimdallr: {Improving} {Compile} {Time} {Correctness} {Checking} for {Message} {Passing} with {Rust}},
	isbn = {978-3-030-90539-2},
	shorttitle = {heimdallr},
	doi = {10.1007/978-3-030-90539-2_13},
	abstract = {Message passing is the foremost parallelization method used in high-performance computing (HPC). Parallel programming in general and especially message passing strongly increase the complexity and susceptibility to errors of programs. The de-facto standard technologies used to realize message passing applications in HPC are MPI with C/C++ or Fortran code. These technologies offer high performance but do not come with many compile-time correctness guarantees and are quite error-prone. This paper presents our work on a message passing library implemented in Rust that focuses on compile-time correctness checks. In our design, we apply Rust’s memory and concurrency safety features to a message passing context and show how common error classes from MPI applications can be avoided with this approach.},
	language = {en},
	booktitle = {High {Performance} {Computing}},
	publisher = {Springer International Publishing},
	author = {Blesel, Michael and Kuhn, Michael and Squar, Jannek},
	editor = {Jagode, Heike and Anzt, Hartwig and Ltaief, Hatem and Luszczek, Piotr},
	year = {2021},
	keywords = {Compile-time checks, MPI, Message passing, Rust},
	pages = {199--211},
}

@inproceedings{trongeEmbeddingRustOpen2023,
	address = {New York, NY, USA},
	series = {{SC}-{W} '23},
	title = {Embedding {Rust} within {Open} {MPI}},
	isbn = {9798400707858},
	url = {https://doi.org/10.1145/3624062.3624112},
	doi = {10.1145/3624062.3624112},
	abstract = {The Message-Passing Interface (MPI) requires implementations that are able to adapt to new hardware and architectures while ensuring correctness and usability. The most widely used MPI implementations, however, are written in older programming languages that can lead to memory-unsafe code with poor isolation between modules, and complicated interfaces that can lead to serious bugs, all of which leads to difficulty in testing, debugging, and checking for correctness. In order to improve development of MPI implementations, we posit that new components, and key existing code segments, may benefit from being written in the Rust programming language. In this work we reimplement a core component of Open MPI used for intra-node communication in Rust and show that it achieves performance approaching that of the existing, highly optimized, C code, demonstrating that Rust is able to provide performance while allowing for better testing, memory safety guarantees, and correctness.},
	urldate = {2024-01-02},
	booktitle = {Proceedings of the {SC} '23 {Workshops} of {The} {International} {Conference} on {High} {Performance} {Computing}, {Network}, {Storage}, and {Analysis}},
	publisher = {Association for Computing Machinery},
	author = {Tronge, Jake and Pritchard, Howard},
	month = nov,
	year = {2023},
	pages = {438--447},
}

@misc{ImprovingInteroperabilityRust,
	title = {Improving {Interoperability} {Between} {Rust} and {C}++},
	url = {https://security.googleblog.com/2024/02/improving-interoperability-between-rust-and-c.html},
	abstract = {Posted by Lars Bergstrom – Director, Android Platform Tools \& Libraries and Chair of the Rust Foundation Board    Back in 2021, we announced...},
	language = {en},
	urldate = {2024-03-04},
	journal = {Google Online Security Blog},
}

@misc{noauthor_manual_nodate,
	title = {Manual {Partition} {EFI} question - {General} system / {EndeavourOS} installation - {EndeavourOS}},
	url = {https://forum.endeavouros.com/t/manual-partition-efi-question/26649/18},
	urldate = {2024-01-12},
}

@book{CaseMethodFastTrack,
	title = {Case {Method} {Fast}-{Track}},
	url = {https://dl.acm.org/doi/abs/10.5555/561543},
	abstract = {From the Book: In writing this book I tried to achieve two different objectives. The first objective was to provide an overview of fast-track, the techniques it applies, and particularly the manage...},
	language = {EN},
	urldate = {2023-10-11},
	publisher = {Addison-Wesley Longman Publishing Co., Inc.},
	author = {Clegg, Dai and Barker, Richard},
	year = {1994},
}

@misc{osti_1231191,
	title = {{miniMD} v1.0},
	url = {https://www.osti.gov//servlets/purl/1231191},
	abstract = {Simple parallel MD code that serves as a microapplication in the Mantevo suite. Study of computer system design and implementation, benchmarking of new and existing computer systems.},
	author = {Crozier, Paul and Plimpton, Steven},
	month = jun,
	year = {2009},
}

@article{mallinson2013cloverleaf,
	title = {Cloverleaf: {Preparing} hydrodynamics codes for exascale},
	journal = {A New Vintage of Computing : Preliminary Proceedings},
	author = {Mallinson, Andrew and Beckingsale, David A and Gaudin, Wayne and Herdman, J and Levesque, John and Jarvis, Stephen A},
	year = {2013},
}

@misc{GitHubFlow,
	title = {{GitHub} {Flow}},
	url = {https://githubflow.github.io/},
	urldate = {2023-10-07},
}

@misc{IteratorStdIter,
	title = {Iterator in std::iter - {Rust}},
	url = {https://doc.rust-lang.org/std/iter/trait.Iterator.html},
	urldate = {2023-11-21},
}

@misc{VecStdVec,
	title = {Vec in std::vec - {Rust}},
	url = {https://doc.rust-lang.org/std/vec/struct.Vec.html},
	urldate = {2023-11-21},
}

@book{pmbok,
	address = {Newtown Square, PA},
	title = {A {Guide} to the {Project} {Management} {Body} of {Knowledge} ({PMBOK}® {Guide}) – {Seventh} {Edition} and {The} {Standard} for {Project} {Management}},
	isbn = {978-1-935589-67-9},
	publisher = {Project Management Institute},
	author = {{Project Management Institute}},
	year = {2021},
}

@misc{ECPcopaCabanaPIC2023,
	title = {{ECP}-copa/{CabanaPIC}},
	copyright = {BSD-3-Clause},
	url = {https://github.com/ECP-copa/CabanaPIC},
	abstract = {Structured PIC proxy app based on Cabana},
	urldate = {2023-11-21},
	publisher = {Co-design center for Particle Applications (CoPA)},
	author = {Triad National Security, LLC},
	month = nov,
	year = {2023},
	keywords = {cabana, kokkos, particle-in-cell, proxy-application, vpic},
}

@misc{endlerMreIdiomaticrust2023,
	title = {mre/idiomatic-rust},
	url = {https://github.com/mre/idiomatic-rust},
	abstract = {🦀 A peer-reviewed collection of articles/talks/repos which teach concise, idiomatic Rust.},
	urldate = {2023-10-08},
	author = {Endler, Matthias},
	month = oct,
	year = {2023},
	keywords = {ergonomics, idiomatic, idiomatic-rust, rust},
}

@misc{PolarsPolars2023,
	title = {pola-rs/polars},
	copyright = {MIT},
	url = {https://github.com/pola-rs/polars},
	abstract = {Dataframes powered by a multithreaded, vectorized query engine, written in Rust},
	urldate = {2023-11-21},
	publisher = {Polars},
	author = {Polar-rs},
	month = nov,
	year = {2023},
	keywords = {arrow, dataframe, dataframe-library, dataframes, out-of-core, polars, python, rust},
}

@misc{Sanitizers2023,
	title = {sanitizers},
	url = {https://github.com/google/sanitizers},
	abstract = {AddressSanitizer, ThreadSanitizer, MemorySanitizer},
	urldate = {2023-10-08},
	publisher = {Google},
	author = {Google LLC},
	month = oct,
	year = {2023},
}

@misc{TeaLeaf2023,
	title = {{TeaLeaf}},
	url = {https://github.com/UoB-HPC/TeaLeaf},
	abstract = {A fully C-based implementation of the TeaLeaf heat conduction mini-app},
	urldate = {2023-11-21},
	publisher = {University of Bristol High Performance Computing group},
	author = {UK-MAC},
	month = nov,
	year = {2023},
}

@misc{VPFFT2023,
	title = {{VPFFT}},
	url = {https://github.com/exmatex/VPFFT},
	abstract = {Crystal viscoplasticity proxy application.},
	urldate = {2023-11-21},
	publisher = {ExMatEx},
	author = {Los Alamos National Lab},
	month = may,
	year = {2023},
}

@misc{ZoteroYourPersonal,
	title = {Zotero {\textbar} {Your} personal research assistant},
	url = {https://www.zotero.org/},
	urldate = {2023-10-07},
	author = {Corporation for Digital Scholarship},
}

@misc{WhyGitBetter,
	title = {Why {Git} is {Better} {Than} {X}},
	url = {https://z.github.io/whygitisbetter/},
	urldate = {2023-10-07},
	author = {Chacon, Scott},
}

@misc{WhatHPCIntroduction,
	title = {What is {HPC}? {Introduction} to high-performance computing {\textbar} {IBM}},
	shorttitle = {What is {HPC}?},
	url = {https://www.ibm.com/topics/hpc},
	abstract = {High-performance computing (HPC) technology harnesses the power of supercomputers or computer clusters to solve complex problems requiring massive computation.},
	language = {en-us},
	urldate = {2023-10-10},
	author = {IBM Corporation},
}

@misc{WhatCICD,
	title = {What is {CI}/{CD}?},
	url = {https://www.redhat.com/en/topics/devops/what-is-ci-cd},
	abstract = {CI/CD introduces ongoing automation and continuous monitoring throughout the lifecycle of apps, from integration and testing phases to delivery and deployment.},
	language = {en},
	urldate = {2023-10-08},
	author = {Red Hat, Inc.},
}

@misc{WhatAgileAgile2015,
	title = {What is {Agile}? {\textbar} {Agile} 101 {\textbar} {Agile} {Alliance}},
	shorttitle = {What is {Agile}?},
	url = {https://www.agilealliance.org/agile101/},
	abstract = {What is Agile? Agile is a set of methods and practices where solutions evolve through collaboration between self-organizing, cross-functional teams.},
	language = {en-US},
	urldate = {2023-10-07},
	author = {Agile Alliance},
	month = jun,
	year = {2015},
}

@misc{ValgrindHome,
	title = {Valgrind {Home}},
	url = {https://valgrind.org/},
	urldate = {2023-11-21},
	author = {Valgrind Developers},
}

@misc{Unsized_localsRustUnstable,
	title = {unsized\_locals - {The} {Rust} {Unstable} {Book}},
	url = {https://doc.rust-lang.org/beta/unstable-book/language-features/unsized-locals.html},
	urldate = {2023-11-21},
	author = {Rust Project},
}

@incollection{klabnikUnderstandingOwnership2018,
	title = {Understanding {Ownership}},
	isbn = {978-1-59327-828-1},
	language = {en},
	booktitle = {The {Rust} {Programming} {Language}},
	publisher = {No Starch Press},
	author = {Klabnik, Steve and Nichols, Carol},
	year = {2018},
	note = {Google-Books-ID: iVv6DwAAQBAJ},
	keywords = {COMPUTERS / Programming / General, Computers / Programming / Open Source},
	pages = {57},
}

@misc{UKMiniAppConsortium,
	title = {{UK} {Mini}-{App} {Consortium}},
	url = {https://uk-mac.github.io/},
	urldate = {2023-10-07},
	author = {UK-MAC},
}

@misc{TelemetryGoToolchain,
	title = {telemetry in the {Go} toolchain · golang/go · {Discussion} \#58409},
	url = {https://github.com/golang/go/discussions/58409},
	abstract = {Feb 10 5pm US Eastern: Thanks for the lively discussion everyone. It has given me plenty to think about. We are starting to go in circles, and actually new comments are increasingly rare, so I've l...},
	language = {en},
	urldate = {2023-10-08},
	journal = {GitHub},
	author = {Cox, Russ},
}

@misc{TeaLeaf,
	title = {{TeaLeaf}},
	url = {https://uk-mac.github.io/TeaLeaf/},
	urldate = {2023-11-21},
	author = {UK-MAC},
}

@misc{StackOverflowDeveloper,
	title = {Stack {Overflow} {Developer} {Survey} 2023},
	url = {https://survey.stackoverflow.co/2023/},
	abstract = {In May 2023 over 90,000 developers responded to our annual survey about how they learn and level up, which tools they're using, and which ones they want.},
	language = {en},
	urldate = {2023-10-06},
	journal = {Stack Overflow},
	author = {Stack Exchange, Inc.},
}

@misc{SLOCCount,
	title = {{SLOCCount}},
	url = {https://dwheeler.com/sloccount/},
	urldate = {2023-10-21},
	author = {Wheeler, David},
}

@misc{ScientificComputingRTP,
	title = {Scientific {Computing} {RTP}},
	url = {https://warwick.ac.uk/research/rtp/sc/},
	urldate = {2023-10-07},
	author = {University of Warwick},
}

@misc{RustProgrammingLanguage,
	title = {Rust {Programming} {Language}},
	url = {https://www.rust-lang.org/},
	urldate = {2023-10-06},
	author = {Rust Project},
}

@misc{RAJAPortabilitySuite,
	title = {{RAJA} {Portability} {Suite} {\textbar} {Computing}},
	url = {https://computing.llnl.gov/projects/raja-managing-application-portability-next-generation-platforms},
	urldate = {2023-11-21},
	author = {Lawrence Livermore National Laboratory},
}

@misc{RfcsText1909unsizedrvalues,
	title = {rfcs/text/1909-unsized-rvalues.md at master · rust-lang/rfcs},
	url = {https://github.com/rust-lang/rfcs/blob/master/text/1909-unsized-rvalues.md},
	abstract = {RFCs for changes to Rust. Contribute to rust-lang/rfcs development by creating an account on GitHub.},
	language = {en},
	urldate = {2023-11-21},
	journal = {GitHub},
	author = {Rust Project},
}

@misc{RaceConditionVs,
	title = {Race {Condition} vs. {Data} {Race} – {Embedded} in {Academia}},
	url = {https://blog.regehr.org/archives/490},
	urldate = {2023-10-08},
	author = {Regehr, John},
}

@misc{PerfWiki,
	title = {Perf {Wiki}},
	url = {https://perf.wiki.kernel.org/index.php/Main_Page},
	urldate = {2023-11-21},
	author = {Linux Kernel},
}

@misc{OxidationMozillaWiki,
	title = {Oxidation - {MozillaWiki}},
	url = {https://wiki.mozilla.org/Oxidation},
	urldate = {2023-10-10},
	author = {Mozilla Foundation},
}

@misc{OverleafOnlineLaTeX,
	title = {Overleaf, {Online} {LaTeX} {Editor}},
	url = {https://www.overleaf.com},
	abstract = {An online LaTeX editor that’s easy to use. No installation, real-time collaboration, version control, hundreds of LaTeX templates, and more.},
	language = {en},
	urldate = {2023-10-07},
	author = {WriteLaTeX Limited},
}

@misc{NSAReleasesGuidance,
	title = {{NSA} {Releases} {Guidance} on {How} to {Protect} {Against} {Software} {Memory} {Safety} {Issues}},
	url = {https://www.nsa.gov/Press-Room/News-Highlights/Article/Article/3215760/nsa-releases-guidance-on-how-to-protect-against-software-memory-safety-issues/},
	abstract = {The National Security Agency (NSA) published guidance today to help software developers and operators prevent and mitigate software memory safety issues, which account for a large portion of},
	language = {en-US},
	urldate = {2023-10-08},
	journal = {National Security Agency/Central Security Service},
	author = {NSA Media Relations},
}

@misc{Microsoft70Percent,
	title = {Microsoft: 70 percent of all security bugs are memory safety issues},
	shorttitle = {Microsoft},
	url = {https://www.zdnet.com/article/microsoft-70-percent-of-all-security-bugs-are-memory-safety-issues/},
	abstract = {Percentage of memory safety issues has been hovering at 70 percent for the past 12 years.},
	language = {en},
	urldate = {2023-10-07},
	journal = {ZDNET},
	author = {Cimpanu, Catalin},
}

@misc{MemorySafety,
	title = {Memory safety},
	url = {https://www.chromium.org/Home/chromium-security/memory-safety/},
	urldate = {2023-10-07},
	author = {Chromium Authors},
}

@misc{JournalDescriptionInternational,
	title = {Journal {Description}: {The} {International} {Journal} of {High} {Performance} {Computing} {Applications}},
	shorttitle = {Journal {Description}},
	url = {https://journals.sagepub.com/description/HPC},
	abstract = {Journal description for The International Journal of High Performance Computing Applications},
	language = {en},
	urldate = {2023-10-10},
	journal = {Sage Journals},
	author = {SAGE Publications},
}

@misc{IntroductionRustExample,
	title = {Introduction - {Rust} {By} {Example}},
	url = {https://doc.rust-lang.org/rust-by-example/},
	urldate = {2023-11-21},
	author = {Rust Project},
}

@misc{IBMCloud,
	title = {{IBM} {Cloud}},
	url = {https://www.ibm.com/cloud},
	abstract = {IBM Cloud with Red Hat offers market-leading security, enterprise scalability and open innovation to unlock the full potential of cloud and AI.},
	language = {en-us},
	urldate = {2023-10-07},
	author = {IBM Corporation},
}

@misc{AmNoLonger2023,
	title = {I {Am} {No} {Longer} {Speaking} at {RustConf} 2023},
	url = {https://thephd.dev/i-am-no-longer-speaking-at-rustconf-2023},
	abstract = {I will no longer be speaking at RustConf 2023 about A (Possible) Future for Compile-Time Programming.},
	language = {en},
	urldate = {2023-10-07},
	journal = {The Pasture},
	author = {Meneide, JeanHeyd},
	month = may,
	year = {2023},
}

@misc{GitHubRESTAPI,
	title = {{GitHub} {REST} {API} documentation},
	url = {https://docs.github.com/en/rest},
	abstract = {To create integrations, retrieve data, and automate your workflows, build with the GitHub REST API.},
	language = {en},
	urldate = {2023-11-21},
	journal = {GitHub Docs},
	author = {GitHub Inc.},
}

@misc{FixPerformanceBottlenecks,
	title = {Fix {Performance} {Bottlenecks} with {Intel}® {VTune}™ {Profiler}},
	url = {https://www.intel.com/content/www/us/en/developer/tools/oneapi/vtune-profiler.html},
	abstract = {Use advanced sampling and profiling methods to quickly analyze code, isolate issues, and deliver performance insight on modern CPUs, GPUs, and FPGAs.},
	language = {en},
	urldate = {2023-11-21},
	journal = {Intel},
	author = {Intel Corporation},
}

@misc{ECPProxyApps2018,
	title = {{ECP} {Proxy} {Apps} {Suite}},
	url = {https://proxyapps.exascaleproject.org/ecp-proxy-apps-suite/},
	abstract = {Visit the post for more.},
	language = {en-US},
	urldate = {2023-10-07},
	journal = {ECP Proxy Applications},
	author = {Exascale Project},
	month = sep,
	year = {2018},
}

@misc{ECPProxyApplications,
	title = {{ECP} {Proxy} {Applications}},
	url = {https://proxyapps.exascaleproject.org/},
	language = {en-US},
	urldate = {2023-10-07},
	journal = {ECP Proxy Applications},
	author = {Exascale Project},
}

@misc{CloverLeaf,
	title = {{CloverLeaf}},
	url = {https://uk-mac.github.io/CloverLeaf/},
	urldate = {2023-11-21},
	author = {UK-MAC},
}

@misc{ClangTidyExtraClang,
	title = {Clang-{Tidy} — {Extra} {Clang} {Tools} 18.0.0git documentation},
	url = {https://clang.llvm.org/extra/clang-tidy/},
	urldate = {2023-11-21},
	author = {Clang Team},
}

@misc{BehaviorConsideredUndefined,
	title = {Behavior considered undefined - {The} {Rust} {Reference}},
	url = {https://doc.rust-lang.org/reference/behavior-considered-undefined.html},
	urldate = {2023-10-07},
	author = {Rust Project},
}

@misc{AddRFCGovernance,
	title = {Add {RFC} on governance, establishing the {Leadership} {Council} by jntrnr · {Pull} {Request} \#3392 · rust-lang/rfcs},
	url = {https://github.com/rust-lang/rfcs/pull/3392},
	abstract = {This RFC was jointly authored by @jntrnr (Core), @joshtriplett (Lang Team Lead), @khionu (Moderation), @Mark-Simulacrum (Core Project Director, Release Lead), @rylev (Core Project Director), @techn...},
	language = {en},
	urldate = {2023-10-07},
	journal = {GitHub},
	author = {Turner, Sophia},
}

@misc{KokkosEcosystem,
	title = {About – {Kokkos} {Ecosystem}},
	url = {https://kokkos.org/about/},
	language = {en-US},
	urldate = {2023-11-21},
	author = {Exacale Project},
}

@article{hoareAxiomaticBasisComputer1969,
	title = {An axiomatic basis for computer programming},
	volume = {12},
	issn = {0001-0782},
	url = {https://dl.acm.org/doi/10.1145/363235.363259},
	doi = {10.1145/363235.363259},
	abstract = {In this paper an attempt is made to explore the logical foundations of computer programming by use of techniques which were first applied in the study of geometry and have later been extended to other branches of mathematics. This involves the elucidation of sets of axioms and rules of inference which can be used in proofs of the properties of computer programs. Examples are given of such axioms and rules, and a formal proof of a simple theorem is displayed. Finally, it is argued that important advantage, both theoretical and practical, may follow from a pursuance of these topics.},
	number = {10},
	urldate = {2023-12-02},
	journal = {Communications of the ACM},
	author = {Hoare, C. A. R.},
	month = oct,
	year = {1969},
	keywords = {axiomatic method, formal language definition, machine-independent programming, program documentation, programming language design, theory of programming' proofs of programs},
	pages = {576--580},
}

@book{automatedDefectPrevention,
	address = {Hoboken, New Jersey},
	title = {Automated defect prevention: best practices in software management},
	isbn = {0470165170;9780470165171;},
	language = {English},
	publisher = {Wiley-Interscience},
	author = {Huizinga, Dorota and Kolawa, Adam},
	year = {2007},
	keywords = {Automatic control, Computer programs, Correctness, Data processing, Debugging in computer science, Prevention, Software failures, Software maintenance, Testing},
}

@article{blanco-cuaresmaWhatCanProgramming2016,
	title = {What can the programming language {Rust} do for astrophysics?},
	volume = {12},
	issn = {1743-9213, 1743-9221},
	url = {https://www.cambridge.org/core/journals/proceedings-of-the-international-astronomical-union/article/what-can-the-programming-language-rust-do-for-astrophysics/B51B6DF72B7641F2352C05A502F3D881},
	doi = {10.1017/S1743921316013168},
	abstract = {The astrophysics community uses different tools for computational tasks such as complex systems simulations, radiative transfer calculations or big data. Programming languages like Fortran, C or C++ are commonly present in these tools and, generally, the language choice was made based on the need for performance. However, this comes at a cost: safety. For instance, a common source of error is the access to invalid memory regions, which produces random execution behaviors and affects the scientific interpretation of the results.In 2015, Mozilla Research released the first stable version of a new programming language named Rust. Many features make this new language attractive for the scientific community, it is open source and it guarantees memory safety while offering zero-cost abstraction.We explore the advantages and drawbacks of Rust for astrophysics by re-implementing the fundamental parts of Mercury-T, a Fortran code that simulates the dynamical and tidal evolution of multi-planet systems.},
	language = {en},
	number = {S325},
	urldate = {2023-10-10},
	journal = {Proceedings of the International Astronomical Union},
	author = {Blanco-Cuaresma, Sergi and Bolmont, Emeline},
	month = oct,
	year = {2016},
	note = {Publisher: Cambridge University Press},
	keywords = {N-Body, Rust, exoplanets, programming languages, simulations},
	pages = {341--344},
}

@inproceedings{allamanisMiningIdiomsSource2014,
	title = {Mining {Idioms} from {Source} {Code}},
	url = {http://arxiv.org/abs/1404.0417},
	doi = {10.1145/2635868.2635901},
	abstract = {We present the first method for automatically mining code idioms from a corpus of previously written, idiomatic software projects. We take the view that a code idiom is a syntactic fragment that recurs across projects and has a single semantic role. Idioms may have metavariables, such as the body of a for loop. Modern IDEs commonly provide facilities for manually defining idioms and inserting them on demand, but this does not help programmers to write idiomatic code in languages or using libraries with which they are unfamiliar. We present HAGGIS, a system for mining code idioms that builds on recent advanced techniques from statistical natural language processing, namely, nonparametric Bayesian probabilistic tree substitution grammars. We apply HAGGIS to several of the most popular open source projects from GitHub. We present a wide range of evidence that the resulting idioms are semantically meaningful, demonstrating that they do indeed recur across software projects and that they occur more frequently in illustrative code examples collected from a Q\&A site. Manual examination of the most common idioms indicate that they describe important program concepts, including object creation, exception handling, and resource management.},
	urldate = {2023-11-21},
	booktitle = {Proceedings of the 22nd {ACM} {SIGSOFT} {International} {Symposium} on {Foundations} of {Software} {Engineering}},
	author = {Allamanis, Miltiadis and Sutton, Charles},
	month = nov,
	year = {2014},
	note = {arXiv:1404.0417 [cs]},
	keywords = {Computer Science - Software Engineering},
	pages = {472--483},
}

@article{hestenesMethodsConjugateGradients1952,
	title = {Methods of {Conjugate} {Gradients} for {Solving} {Linear} {Systems}},
	volume = {49},
	doi = {10.6028/jres.049.044},
	number = {6},
	journal = {Journal of Research of the National Bureau of Standards},
	author = {Hestenes, Magnus R and Steifel, Eduard},
	month = dec,
	year = {1952},
	pages = {409 -- 436},
}

@article{garciaKremlinRethinkingRebooting2011,
	title = {Kremlin: rethinking and rebooting gprof for the multicore age},
	volume = {46},
	issn = {0362-1340},
	shorttitle = {Kremlin},
	url = {https://doi.org/10.1145/1993316.1993553},
	doi = {10.1145/1993316.1993553},
	abstract = {Many recent parallelization tools lower the barrier for parallelizing a program, but overlook one of the first questions that a programmer needs to answer: which parts of the program should I spend time parallelizing? This paper examines Kremlin, an automatic tool that, given a serial version of a program, will make recommendations to the user as to what regions (e.g. loops or functions) of the program to attack first. Kremlin introduces a novel hierarchical critical path analysis and develops a new metric for estimating the potential of parallelizing a region: self-parallelism. We further introduce the concept of a parallelism planner, which provides a ranked order of specific regions to the programmer that are likely to have the largest performance impact when parallelized. Kremlin supports multiple planner personalities, which allow the planner to more effectively target a particular programming environment or class of machine. We demonstrate the effectiveness of one such personality, an OpenMP planner, by comparing versions of programs that are parallelized according to Kremlin's plan against third-party manually parallelized versions. The results show that Kremlin's OpenMP planner is highly effective, producing plans whose performance is typically comparable to, and sometimes much better than, manual parallelization. At the same time, these plans would require that the user parallelize significantly fewer regions of the program.},
	number = {6},
	urldate = {2023-11-21},
	journal = {ACM SIGPLAN Notices},
	author = {Garcia, Saturnino and Jeon, Donghwan and Louie, Christopher M. and Taylor, Michael Bedford},
	month = jun,
	year = {2011},
	keywords = {hierarchical critical path analysis, parallel software engineering, parallelism planner, self-parallelism},
	pages = {458--469},
}

@techreport{herouxHPCCGSolverPackage2007,
	title = {{HPCCG} {Solver} {Package}},
	url = {https://www.osti.gov/biblio/1230960},
	abstract = {HPCCG is a simple PDE application and preconditioned conjugate gradient solver that solves a linear system on a beam-shaped domain. Although it does not address many performance issues present in real engineering applications, such as load imbalance and preconditioner scalability, it can serve as a first "sanity test" of new processor design choices, inter-connect network design choices and the scalability of a new computer system. Because it is self-contained, easy to compile and easily scaled to 100s or 1000s of porcessors, it can be an attractive study code for computer system designers.},
	language = {en},
	number = {HPCCG; 002048MLTPL00},
	urldate = {2023-11-21},
	institution = {Sandia National Laboratories (SNL), Albuquerque, NM, and Livermore, CA (United States)},
	author = {Heroux, Michael A.},
	month = mar,
	year = {2007},
}

@article{grahamGprofCallGraph1982,
	title = {Gprof: {A} call graph execution profiler},
	volume = {17},
	issn = {0362-1340},
	shorttitle = {Gprof},
	url = {https://dl.acm.org/doi/10.1145/872726.806987},
	doi = {10.1145/872726.806987},
	abstract = {Large complex programs are composed of many small routines that implement abstractions for the routines that call them. To be useful, an execution profiler must attribute execution time in a way that is significant for the logical structure of a program as well as for its textual decomposition. This data must then be displayed to the user in a convenient and informative way. The gprof profiler accounts for the running time of called routines in the running time of the routines that call them. The design and use of this profiler is described.},
	number = {6},
	urldate = {2023-11-21},
	journal = {ACM SIGPLAN Notices},
	author = {Graham, Susan L. and Kessler, Peter B. and Mckusick, Marshall K.},
	month = jun,
	year = {1982},
	pages = {120--126},
}

@article{dongarraNewMetricRanking2016,
	title = {A new metric for ranking high-performance computing systems},
	volume = {3},
	issn = {2095-5138},
	url = {https://doi.org/10.1093/nsr/nwv084},
	doi = {10.1093/nsr/nwv084},
	number = {1},
	urldate = {2023-11-21},
	journal = {National Science Review},
	author = {Dongarra, Jack and Heroux, Michael A. and Luszczek, Piotr},
	month = mar,
	year = {2016},
	pages = {30--35},
}

@article{10.1145/1273442.1250746,
	title = {Valgrind: {A} framework for heavyweight dynamic binary instrumentation},
	volume = {42},
	issn = {0362-1340},
	url = {https://doi.org/10.1145/1273442.1250746},
	doi = {10.1145/1273442.1250746},
	abstract = {Dynamic binary instrumentation (DBI) frameworks make it easy to build dynamic binary analysis (DBA) tools such as checkers and profilers. Much of the focus on DBI frameworks has been on performance; little attention has been paid to their capabilities. As a result, we believe the potential of DBI has not been fully exploited.In this paper we describe Valgrind, a DBI framework designed for building heavyweight DBA tools. We focus on its unique support for shadow values-a powerful but previously little-studied and difficult-to-implement DBA technique, which requires a tool to shadow every register and memory value with another value that describes it. This support accounts for several crucial design features that distinguish Valgrind from other DBI frameworks. Because of these features, lightweight tools built with Valgrind run comparatively slowly, but Valgrind can be used to build more interesting, heavyweight tools that are difficult or impossible to build with other DBI frameworks such as Pin and DynamoRIO.},
	number = {6},
	journal = {SIGPLAN Not.},
	author = {Nethercote, Nicholas and Seward, Julian},
	month = jun,
	year = {2007},
	note = {Number of pages: 12
Place: New York, NY, USA
Publisher: Association for Computing Machinery
tex.issue\_date: June 2007},
	keywords = {Memcheck, Valgrind, dynamic binary analysis, dynamic binary instrumentation, shadow values},
	pages = {89--100},
}

@techreport{heroux2013mantevo,
	title = {Mantevo suite 1.0.},
	institution = {Sandia National Lab.(SNL-NM), Albuquerque, NM (United States)},
	author = {Heroux, Michael Allen and Barrett, Richard Frederick and Willenbring, James Michael and Hammond, Simon David and Richards, David and Mohd-Yusof, Jamal and Herdman, Andrew},
	year = {2013},
}

@incollection{polyak1987introduction,
	title = {The {Conjugate} {Gradient} {Method}},
	url = {https://www.researchgate.net/profile/Boris-Polyak-2/publication/342978480_Introduction_to_Optimization/links/5f1033e5299bf1e548ba4636/Introduction-to-Optimization.pdf},
	booktitle = {Introduction to optimization},
	author = {Polyak, Boris T},
	year = {1987},
	note = {Publisher: New York, Optimization Software,},
	pages = {219 -- 220},
}

@inproceedings{jimenez_quiho_2018,
	title = {quiho: {Automated} {Performance} {Regression} {Testing} {Using} {Inferred} {Resource} {Utilization} {Profiles}},
	shorttitle = {quiho},
	doi = {10.1145/3184407.3184422},
	abstract = {We introduce quiho, a framework for profiling application performance that can be used in automated performance regression tests. quiho profiles an application by applying sensitivity analysis, in particular statistical regression analysis (SRA), using application-independent performance feature vectors that characterize the performance of machines. The result of the SRA, feature importance specifically, is used as a proxy to identify hardware and low-level system software behavior. The relative importance of these features serve as a performance profile of an application (termed inferred resource utilization profile or IRUP), which is used to automatically validate performance behavior across multiple revisions of an application»s code base without having to instrument code or obtain performance counters. We demonstrate that quiho can successfully discover performance regressions by showing its effectiveness in profiling application performance for synthetically introduced regressions as well as those found in real-world applications.},
	author = {Jimenez, Ivo and Watkins, Noah and Sevilla, Michael and Lofstead, Jay and Maltzahn, Carlos},
	month = mar,
	year = {2018},
	pages = {273--284},
}

@inproceedings{lange_palacios_2010,
	title = {Palacios and {Kitten}: {New} high performance operating systems for scalable virtualized and native supercomputing},
	shorttitle = {Palacios and {Kitten}},
	doi = {10.1109/IPDPS.2010.5470482},
	abstract = {Palacios is a new open-source VMM under development at Northwestern University and the University of New Mexico that enables applications executing in a virtualized environment to achieve scalable high performance on large machines. Palacios functions as a modularized extension to Kitten, a high performance operating system being developed at Sandia National Laboratories to support large-scale supercomputing applications. Together, Palacios and Kitten provide a thin layer over the hardware to support full-featured virtualized environments alongside Kitten's lightweight native environment. Palacios supports existing, unmodified applications and operating systems by using the hardware virtualization technologies in recent AMD and Intel processors. Additionally, Palacios leverages Kitten's simple memory management scheme to enable low-overhead pass-through of native devices to a virtualized environment. We describe the design, implementation, and integration of Palacios and Kitten. Our benchmarks show that Palacios provides near native (within 5\%), scalable performance for virtualized environments running important parallel applications. This new architecture provides an incremental path for applications to use supercomputers, running specialized lightweight host operating systems, that is not significantly performance-compromised.},
	author = {Lange, John and Pedretti, Kevin and Hudson, Trammell and Dinda, Peter and Cui, Zheng and Xia, Lei and Bridges, Patrick and Gocke, Andy and Jaconette, Steven and Levenhagen, Mike and Brightwell, Ron},
	month = may,
	year = {2010},
	pages = {1--12},
}

@article{matsakis_rust_2014,
	title = {The rust language},
	volume = {34},
	issn = {1094-3641},
	url = {https://dl.acm.org/doi/10.1145/2692956.2663188},
	doi = {10.1145/2692956.2663188},
	abstract = {Rust is a new programming language for developing reliable and efficient systems. It is designed to support concurrency and parallelism in building applications and libraries that take full advantage of modern hardware. Rust's static type system is safe1 and expressive and provides strong guarantees about isolation, concurrency, and memory safety. Rust also offers a clear performance model, making it easier to predict and reason about program efficiency. One important way it accomplishes this is by allowing fine-grained control over memory representations, with direct support for stack allocation and contiguous record storage. The language balances such controls with the absolute requirement for safety: Rust's type system and runtime guarantee the absence of data races, buffer overflows, stack overflows, and accesses to uninitialized or deallocated memory.},
	number = {3},
	urldate = {2023-10-10},
	journal = {ACM SIGAda Ada Letters},
	author = {Matsakis, Nicholas D. and Klock, Felix S.},
	month = oct,
	year = {2014},
	keywords = {affine type systems, memory management, rust, systems programming},
	pages = {103--104},
}

@article{millerEmpiricalStudyReliability1990,
	title = {An empirical study of the reliability of {UNIX} utilities},
	volume = {33},
	issn = {0001-0782},
	url = {https://dl.acm.org/doi/10.1145/96267.96279},
	doi = {10.1145/96267.96279},
	abstract = {The following section describes the tools we built to test the utilities. These tools include the fuzz (random character) generator, ptyjig (to test interactive utilities), and scripts to automate the testing process. Next, we will describe the tests we performed, giving the types of input we presented to the utilities. Results from the tests will follow along with an analysis of the results, including identification and classification of the program bugs that caused the crashes. The final section presents concluding remarks, including suggestions for avoiding the types of problems detected by our study and some commentary on the bugs we found. We include an Appendix with the user manual pages for fuzz and ptyjig.},
	number = {12},
	urldate = {2023-10-10},
	journal = {Communications of the ACM},
	author = {Miller, Barton P. and Fredriksen, Lars and So, Bryan},
	month = dec,
	year = {1990},
	pages = {32--44},
}

@inproceedings{stepanovMemorySanitizerFastDetector2015,
	title = {{MemorySanitizer}: {Fast} detector of uninitialized memory use in {C}++},
	shorttitle = {{MemorySanitizer}},
	url = {https://ieeexplore.ieee.org/abstract/document/7054186},
	doi = {10.1109/CGO.2015.7054186},
	abstract = {This paper presents MemorySanitizer, a dynamic tool that detects uses of uninitialized memory in C and C++. The tool is based on compile time instrumentation and relies on bit-precise shadow memory at run-time. Shadow propagation technique is used to avoid false positive reports on copying of uninitialized memory. MemorySanitizer finds bugs at a modest cost of 2.5× in execution time and 2× in memory usage; the tool has an optional origin tracking mode that provides better reports with moderate extra overhead. The reports with origins are more detailed compared to reports from other similar tools; such reports contain names of local variables and the entire history of the uninitialized memory including intermediate stores. In this paper we share our experience in deploying the tool at a large scale and demonstrate the benefits of compile-time instrumentation over dynamic binary instrumentation.},
	urldate = {2023-10-10},
	booktitle = {2015 {IEEE}/{ACM} {International} {Symposium} on {Code} {Generation} and {Optimization} ({CGO})},
	author = {Stepanov, Evgeniy and Serebryany, Konstantin},
	month = feb,
	year = {2015},
	pages = {46--55},
}

@article{liangFuzzingStateArt2018,
	title = {Fuzzing: {State} of the {Art}},
	volume = {67},
	issn = {1558-1721},
	shorttitle = {Fuzzing},
	url = {https://ieeexplore.ieee.org/abstract/document/8371326},
	doi = {10.1109/TR.2018.2834476},
	abstract = {As one of the most popular software testing techniques, fuzzing can find a variety of weaknesses in a program, such as software bugs and vulnerabilities, by generating numerous test inputs. Due to its effectiveness, fuzzing is regarded as a valuable bug hunting method. In this paper, we present an overview of fuzzing that concentrates on its general process, as well as classifications, followed by detailed discussion of the key obstacles and some state-of-the-art technologies which aim to overcome or mitigate these obstacles. We further investigate and classify several widely used fuzzing tools. Our primary goal is to equip the stakeholder with a better understanding of fuzzing and the potential solutions for improving fuzzing methods in the spectrum of software testing and security. To inspire future research, we also predict some future directions with regard to fuzzing.},
	number = {3},
	urldate = {2023-10-10},
	journal = {IEEE Transactions on Reliability},
	author = {Liang, Hongliang and Pei, Xiaoxiao and Jia, Xiaodong and Shen, Wuwei and Zhang, Jian},
	month = sep,
	year = {2018},
	note = {Conference Name: IEEE Transactions on Reliability},
	pages = {1199--1218},
}

@inproceedings{leeBuildingMemorysafeNetwork2017,
	title = {Toward building memory-safe network functions with modest performance overhead},
	booktitle = {{ACM} {SIGCOMM} {NetPL} {Workshop}},
	publisher = {ACM SIGCOMM},
	author = {Lee, Keunhong and Woo, Shinae and Seo, Sanghyeon and Park, Jihyeok and Ryu, Sukyoung and Moon, Sue},
	year = {2017},
}

@book{klabnikRustProgrammingLanguage2018,
	title = {The {Rust} {Programming} {Language}},
	isbn = {978-1-59327-828-1},
	url = {https://doc.rust-lang.org/book/title-page.html},
	abstract = {The Rust Programming Language is the official book on Rust, an open-source, community-developed systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety. This is the undisputed go-to guide to Rust, written by two members of the Rust core team, with feedback and contributions from 42 members of the community. The book assumes that you've written code in another programming language but makes no assumptions about which one, meaning the material is accessible and useful to developers from a wide variety of programming backgrounds.  Known by the Rust community as "The Book," The Rust Programming Language includes concept chapters, where you'll learn about a particular aspect of Rust, and project chapters, where you'll apply what you've learned so far to build small programs.  The Book opens with a quick hands-on project to introduce the basics then explores key concepts in depth, such as ownership, the type system, error handling, and fearless concurrency. Next come detailed explanations of Rust-oriented perspectives on topics like pattern matching, iterators, and smart pointers, with concrete examples and exercises--taking you from theory to practice.  The Rust Programming Language will also show you how to: - Grasp important concepts unique to Rust, like ownership, borrowing, and  lifetimes- Use Cargo, Rust's built-in package manager, to build and maintain your code,  including downloading and building dependencies- Effectively use Rust's zero-cost abstractions and employ your own  You'll learn to develop reliable code that's speed and memory efficient, while avoiding the infamous and arcane programming pitfalls common at the systems level. When you need to dive down into lower-level control, this guide will show you how without taking on the customary risk of crashes or security holes and without requiring you to learn the fine points of a fickle toolchain.  You'll also learn how to create command line programs, build single- and multithreaded web servers, and much more.  The Rust Programming Language fully embraces Rust's potential to empower its users. This friendly and approachable guide will help you build not only your knowledge of Rust but also your ability to program with confidence in a wider variety of domains.},
	language = {en},
	publisher = {No Starch Press},
	author = {Klabnik, Steve and Nichols, Carol},
	year = {2018},
	note = {Google-Books-ID: iVv6DwAAQBAJ},
	keywords = {COMPUTERS / Programming / General, Computers / Programming / Open Source},
}

@inproceedings{matsakisRustLanguage2014,
	title = {The {Rust} {Language}},
	volume = {34},
	booktitle = {{ACM} {SIGAda} {Ada} {Letters}},
	publisher = {ACM},
	author = {Matsakis, Nicholas D and Klock II, Felix S},
	year = {2014},
	note = {Issue: 3},
	pages = {103--104},
}

@misc{beckManifestoAgileSoftware2001,
	title = {Manifesto for {Agile} {Software} {Development}},
	url = {http://www.agilemanifesto.org/},
	author = {Beck, Kent and Beedle, Mike and van Bennekum, Arie and Cockburn, Alistair and Cunningham, Ward and Fowler, Martin and Grenning, James and Highsmith, Jim and Hunt, Andrew and Jeffries, Ron and Kern, Jon and Marick, Brian and Martin, Robert C. and Mellor, Steve and Schwaber, Ken and Sutherland, Jeff and Thomas, Dave},
	year = {2001},
	note = {Publication Title: Manifesto for Agile Software Development},
	keywords = {imported},
}

@article{ungerHazardsCriticalRaces1995,
	title = {Hazards, critical races, and metastability},
	volume = {44},
	issn = {1557-9956},
	url = {https://ieeexplore.ieee.org/document/391185},
	doi = {10.1109/12.391185},
	abstract = {The various modes of failure of asynchronous sequential logic circuits due to timing problems are considered. These are hazards, critical races and metastable states. It is shown that there is a mechanism common to all forms of hazards and to metastable states. A similar mechanism, with added complications, is shown to characterize critical races. Means for defeating various types of hazards and critical races through the use of one-sided delay constraints are introduced. A method is described for determining from a flow table situations in which metastable states may be entered. A circuit technique is presented for extending a previously known technique for defeating metastability problems in self-timed systems. It is shown that the use of simulation for verifying the correctness of a circuit with given bounds on the branch delays cannot be relied upon to expose all timing problems. An example is presented that refutes a plausible conjecture that replacing pure delays with inertial delays can never introduce, but only eliminate glitches.{\textless}{\textgreater}},
	number = {6},
	urldate = {2023-10-07},
	journal = {IEEE Transactions on Computers},
	author = {Unger, S.H.},
	month = jun,
	year = {1995},
	note = {Conference Name: IEEE Transactions on Computers},
	pages = {754--768},
}

@book{matzingerHandsOnDataStructures2019,
	title = {Hands-{On} {Data} {Structures} and {Algorithms} with {Rust}: {Learn} programming techniques to build effective, maintainable, and readable code in {Rust} 2018},
	isbn = {978-1-78899-149-0},
	shorttitle = {Hands-{On} {Data} {Structures} and {Algorithms} with {Rust}},
	abstract = {Design and implement professional level programs by exploring modern data structures and algorithms in Rust.Key FeaturesUse data structures such as arrays, stacks, trees, lists and graphs with real-world examplesLearn the functional and reactive implementations of the traditional data structuresExplore illustrations to present data structures and algorithms, as well as their analysis, in a clear, visual manner.Book DescriptionRust has come a long way and is now utilized in several contexts. Its key strengths are its software infrastructure and resource-constrained applications, including desktop applications, servers, and performance-critical applications, not forgetting its importance in systems\&\#39; programming. This book will be your guide as it takes you through implementing classic data structures and algorithms in Rust, helping you to get up and running as a confident Rust programmer. The book begins with an introduction to Rust data structures and algorithms, while also covering essential language constructs. You will learn how to store data using linked lists, arrays, stacks, and queues. You will also learn how to implement sorting and searching algorithms. You will learn how to attain high performance by implementing algorithms to string data types and implement hash structures in algorithm design. The book will examine algorithm analysis, including Brute Force algorithms, Greedy algorithms, Divide and Conquer algorithms, Dynamic Programming, and Backtracking. By the end of the book, you will have learned how to build components that are easy to understand, debug, and use in different applications.What you will learnDesign and implement complex data structures in RustAnalyze, implement, and improve searching and sorting algorithms in RustCreate and use well-tested and reusable components with RustUnderstand the basics of multithreaded programming and advanced algorithm designBecome familiar with application profiling based on benchmarking and testingExplore the borrowing complexity of implementing algorithmsWho this book is forThis book is for developers seeking to use Rust solutions in a practical/professional setting; who wants to learn essential Data Structures and Algorithms in Rust. It is for developers with basic Rust language knowledge, some experience in other programming languages is required.},
	language = {en},
	publisher = {Packt Publishing Ltd},
	author = {Matzinger, Claus},
	month = jan,
	year = {2019},
	note = {Google-Books-ID: gYKFDwAAQBAJ},
	keywords = {Computers / Distributed Systems / General, Computers / Languages / C, Computers / Languages / General, Computers / Programming / General, Computers / Programming / Parallel},
}
